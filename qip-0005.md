 ```
  QIP: 5
  Layer: Consensus (hard fork)
  Title: Interlink (NiPoPoEM)
  Author: gameofpointers <gameofpointers+qip@quai.org>
  Comments-Summary: No comments yet.
  Comments-URI: https://github.com/quainetwork/qips/wiki/Comments:QIP-0005
  Status: Draft
  Type: Standards Track
  Created: 2023-11-16
  License: BSD-2-Clause
 ```

## Abstract

This QIP defines a block interlink structure to be used in Quai as described in
[1] with few changes.

## Motivation

To Prove/Verify the Proof Of Work done on Quai since the genesis using a
non-interactive proof of proof of work (NiPoPoW). This requires using only
O(log(N)) headers instead of the whole chain history. This enables a light
node(SPV client) to quickly verify the work done on the chain on a node with low
resource. Specifically in Quai, the plan is to use interlinks for work based
snap sync and to use nodes as trustless RPC providers.

## Specification

### Definitions
1. $Order(O)$ - Quai blockchain is organized into different levels, Prime, Region and Zone. Prime has a order of 0, Region has order of 1, Zone has order 2. Order of a Block(B) is defined as $O(B)$. $O(B_p)=0$, $O(B_r)=1$, and $O(B_z)=2$.

### Overview

Interlink data structure is a skip-list that helps a verifier to process a
sparse subset of the blockchain.

Proof of Work function of a Valid Block in the blockchain satisfies the Mining Target(T) i.e $id \leq T$ . 

Traditional Interlinks are organized into different levels.  If $id \leq
\frac{T}{2^{k \times \mu}}$ we say the block is of rank $\mu$. k is a compression
parameter and determines the range between interlinks. This is a small
deviation from the equation in [1] $id \leq \frac{T}{2^{\mu}}$. Having a bigger
range between interlink levels helps with proof compression while preserving
the security guarantees.Rank in Quai is analogous to Level in paper[1]. Since Quai has three layers namely Prime, Region, Zone. Prime chain acts as the base chain and has rank of 0. [1] defines $\mu$ for a block $B$ as $$\mu=\log(T)-\log(id(B))$$
This changes for Quai to $$\mu=\frac{\log(T)-\log(id(B)}{k} $$
In [1] the authors say that for genesis we set the $id=0$ and $\mu=\inf$. Lowest rank $mu=0$ represents every prime block in Quai.

Now for the implemention of interlinks in Quai we have established that,
* Frequency of interlink computation will be on every Prime Block
* The Target used to calculate the Interlinks will be the  $T_p$. ($T_p$ is the Target used to determine if the block is a prime block).  All interlink hash calculations will be done on this Target.

## Implementation

Given the understanding of this theory, for a given k, and num of levels(L) the interlink data structure would look like this.

```{go}
type InterLinks []Hash
```

I propose to add new field to the header:
* Merkle root of the interlink. This will be used to store/reference the interlink data structure. This will be stored in the body of the block.

```{go}
type Header struct {
  ...
  ...
  interlinkRootHash Hash
  ...
  ...
}
```

Logic to calculate the rank of a block
```{go}
func CalculateRank(block) int {
  if Order(block) != 0 {
    return
  }
  rank := 0
  primeTarget := 2^256/block.PrimeDifficultyThreshold
  for i:=0;i<l;i++ {
    id = miningTarget/2^(k*i)
    mu = floor([log(primeTarget)-log(id)]/k)
    if mu > rank {
      rank = mu
    }
  }
  return rank
}
```

Logic to calculate the Interlink root given a block
```{go} 
func CalculateInterlinkRoot(block) Hash {
  if Order(block) != 0 {
    return
  }
  newInterLink = Copy(block.InterLink)
  rank := CalculateRank(block)
  for i:=0;i<rank;i++ {
    newInterLink[i] = block.Hash
  }
  return MerkleRoot(newInterLink)
}
```

Prover and Verifier design, Snap Sync using interlinks will be proposed in future QIPs.

Since there is non-negligible cost to the size of interlink structure and number of levels to be stored in the body of a block, its good to constrain its size. We also want to look at the 
Work compression and speed/cost of producing proofs. Given these constraints and considering the fact that Quai will solve the problem of scaling work based blockchains and becomes the global monetary system that runs for atleast 30 more years, I think we want to pick $k=4$ and $l=4$. This means we would have 4 levels of interlinks and interlinks would have $(target + (4, 8, 12, 16)$ extra bits of zero). On expectation the age of the interlinks would be every $interlink[0]=16$ prime blocks, $interlink[1]=256$ prime blocks, $interlink[2]=4096$ prime blocks, and $interlink[3]=65,536$ prime blocks.

## References

[1]: Non-Interactive Proofs of Proof-of-Work  https://eprint.iacr.org/2017/963.pdf

## Copyright

This QIP licensed under the BSD 2-clause license.
